--- 
title:  "Lecture 4: Post-menopausal Bone Mineral Density"
editor_options: 
  chunk_output_type: console
---

<br>

This session is based on the paper,

Chen, Y., Xiang, J., Wang, Z., Xiao, Y., Zhang, D., Chen, X., Li, H., Liu, M. and Zhang, Q., 2015.  
**Associations of bone mineral density with lean mass, fat mass, and dietary patterns in postmenopausal Chinese women: a 2-year prospective study.**  
PloS one, 10(9), p.e0137097.  

The paper can be found at https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0137097 and the authors have made their data available by placing two Excel files in the dryad repository at https://datadryad.org/stash/dataset/doi:10.5061%2Fdryad.36k08.  

282 postmenopausal women from Harbin City, China were followed between 2009 and 2011 to study changes in bone mineral density (BMD). Dietary data were collected by food frequency questionnaires.

In this session we will cover,
 
* A simple function
* A basic shiny app      

<br>

<hr style = "border:2px solid #3559A6"> </hr>

<br>

```{r echo=FALSE, warning=FALSE, message=FALSE}
library(tidyverse)
```

# A Simple Function

I start with a function, designed for my own use. Since I will be the only user, I will accept responsibility for using the function in a sensible way.  

I assume that I have different measurements and I want to compare them in terms of their coefficients of variation, CV = std/mean. I could of course calculate the CVs in a pipe
```{r}
# random number seed for reproducibility
set.seed(8723)
# randomly generate some test data
tibble( x1 = rnorm(n=20, mean=5, sd=5),
        x2 = rnorm(n=20, mean=10, sd=10)) %>%
  print()  -> testDF

# long dplyr code
testDF %>%
  summarise( m1 = mean(x1),
             s1 = sd(x1),
             m2 = mean(x2),
             s2 = sd(x2) ) %>%
  mutate( cv1 = s1 / m1,
          cv2 = s2 / m2 ) %>%
  select( cv1, cv2) %>%
  print()
```

If I were running an analysis which depended on repeated use of the CV, then it would simplify the code to create a CV function.
```{r}
# function to calculate the coefficient of variation (CV)
# arguments
#    x  a vector of numbers
# returns
#    cv  = sd/mean
#
cv <- function(x) {
  return( sd(x) / mean(x))
}
```

Now the code becomes
```{r}
# shorter code
testDF %>%
  summarise( cv1 = cv(x1),
             cv2 = cv(x2)) %>%
  print()
```

The intermediates means and standard deviations are calculated within the cv functions but they are not returned, so they get discarded. The pipe is no longer cluttered with intermediate variables that need to be discarded.

### Why is this function for personal use  

It fails without warning if

* someone input the wrong type of data, `cv("Jack")`  
* the input has missing values, `cv( c(4, 5, NA, 4))`  
* the data have length one, `cv(9)` (sd fails)  

What is more, I have only run limited checks to ensure that the calculation is correct. If I wanted to share a function with a colleague, I would want to check it more thoroughly.   

### Why is the function simple  

R is extremely flexible; that flexible can be very useful, but it also offers the flexibility to make errors.  

I impose rules that keep my functions simple.  

* my functions have descriptive lower_camel names  
* my comments describe the purpose, inputs and outputs  
* my function can have any number of inputs (arguments)  
* my function returns a single object specified by the `return()` function  
* my function never uses data not passed as an input  

The last of these rules is self-imposed and in the jargon it makes my functions **pure**. Pure in the sense that they are self-contained and isolated from anything that happens in the read of your script.

### The problems with an impure function

Let me create an impure function just for illustration. R let's me do it, though I strongly advise against.

```{r}
# combine x and z and find the CV of the result
# arguments
#   x a vector of numbers
# extra data
#   z is taken from the calling environment
# return
#   the cv of x + z
#
impureCV <- function(x) {
  w <- x + z
  return( sd(w) / mean(w) )
}

# define z
z <- 1
# use the function
testDF %>%
  summarise( cvSbp = impureCV(x1)) %>%
  print()

# give z a different value
z <- 2
# use the function in exactly the same way
testDF %>%
  summarise( cvSbp = impureCV(x1)) %>%
  print()
```

You will see that the result of using impureCV() changes depending on z, a variable that is defined outside of my pipe. I can never test impureCV() because I cannot guarantee what value z will have when the function is used. Remember that z might have been defined 20 or 30 lines earlier on in your script, it might not be a easy to see what is happening as it is in my example.  

You also have to consider what happens if z is not defined. Here I remove z with the rm() function then re-run my pipe.
```{r eval=FALSE}
rm(z)

testDF %>%
  summarise( cvSbp = impureCV(x1)) %>%
  print()
```

The message that I get back is
```{r eval=FALSE}
Error in `summarise()`:
! Problem while computing `cvSbp = impureCV(x1)`.
Caused by error in `impureCV()`:
! object 'z' not found
Backtrace:
  1. testDF %>% summarise(cvSbp = impureCV(x1)) %>% print()
 11. global impureCV(x1)
```

My best advise is, **don't do it**.

<br>

<hr style = "border:2px solid #3559A6"> </hr>

<br>

# Repeating over many columns

Let's consider a repetitive task. I create a tibble of randomly generated data and the use my pure cv() function to calculate all of the coefficients of variation
```{r}
# random number seed for reproducibility
set.seed(8723)
# randomly generate some test data
tibble( x1 = rnorm(n=20, mean=5,  sd=5),
        x2 = rnorm(n=20, mean=10, sd=10),
        x3 = rnorm(n=20, mean=15, sd=15),
        x4 = rnorm(n=20, mean=20, sd=20),
        x5 = rnorm(n=20, mean=25, sd=25) ) %>%
  print()  -> testDF

testDF %>%
  summarise( cv1 = cv(x1),
             cv2 = cv(x2),
             cv3 = cv(x3),
             cv4 = cv(x4),
             cv5 = cv(x5) )
```

Imagine this code, if I needed 50 columns or 500 columns of random data.

### The rule of three

Hadley Wickham advocates the **rule of three**; if you find yourself typing the same or very similar code three or more times, then look for a more efficient way of coding.  

Repetitious code is usually written by cut and paste and errors are easily introduced. Would you spot this cut and paste error? Imagine this error buried in a calculation repeated over 500 columns

```{r}
testDF %>%
  summarise( cv1 = cv(x1),
             cv2 = cv(x2),
             cv3 = cv(x2),
             cv4 = cv(x4),
             cv5 = cv(x5) )
```

## across()

The across() function repeats the same function(s) across multiple columns

```{r}
# apply cv() to columns x1 to x5
testDF %>%
  summarise( across(.cols = x1:x5, .fns = cv) )
```

The key arguments are 

* `.cols` the columns to operate on  
* `.fns`  the function(s) to apply  
* `.names` the names for the results  

Of course, you can use across with any function, not just those that you wrote yourself

```{r}
# apply median() to columns x1 to x5
testDF %>%
  summarise( across(x1:x5, median) )
```

Lazily, I have dropped the argument names and rely on the order.

## Specifying the columns

As well as the colon, there are many other ways to specify the columns that you want to use. The simplest method is to list the column names. across() allows the column names to be quoted or unquoted.
```{r}
testDF %>%
  summarise( across(c("x1", "x2"), mean) )

testDF %>%
  summarise( across(c(x1, x2), mean) )
```


`dplyr` includes a number of functions for picking the columns.  

```{r}
# columns names that start with the same character(s)
testDF %>%
  summarise( across(starts_with("x"), mean) )

# column names that contains specified character(s)
testDF %>%
  summarise( across(contains("3"), mean) )

# columns with a particular characteristic
testDF %>%
  summarise( across(where(is.numeric), mean) )
```


## Multiple functions

across() is not limited to using a single function. If you want to use multiple functions, place them in a list
```{r}
testDF %>%
  summarise( across(x2:x3, list(mean, sd, cv) ) )
```

The functions are distinguished by a number as in _1, _2, _3

If you prefer names rather than numbers, then use a named list of functions

```{r}
testDF %>%
  summarise( across(x2:x3, list(mn=mean, sd=sd, cv=cv) ) )
```

The names are used in place of the numbers.

### A digression: paste or glue?

If you want greater control over the names used by across() then you need to understand the difference between **paste()** and **glue()**.

paste() is the base R function for constructing strings and glue() is the tidyverse equivalent. They do exactly the same job.

Suppose that I want to construct a vector of variable names. With paste I might right
```{r}
paste("x", 1:10, sep="")
```

The code takes "x" and adds the numbers 1 to 10 in turn with no separation between "x" and the number.

No separation is so commonly used that there is even a function paste0() that is the same as paste but without a separator.

```{r}
paste0("x", 1:10)
```

In the tidyverse that have introduced a new function glue() that does the same job with a different syntax.

```{r}
library(glue)

glue("x{1:10}")
```

The part that can change is place in curly brackets.

It does not matter which you use. I often use paste() because I learned it before glue() existed, but if you are not already a paste() user perhaps you should adopt glue().  


## Changing the names

Back to across(), we can create our own names using combinations of {.col} and {.fn} and the glue syntax.

```{r}
testDF %>%
  summarise( across( .cols  = x1:x5, 
                     .fns   = cv, 
                     .names = "CV_{.col}" ) )
```

Here is another variation using a dot (not a style that I ever use)

```{r}
testDF %>%
  summarise( across( .cols  = x1:x5, 
                     .fns   = list(mean, cv), 
                     .names = "{.col}.{.fn}" ) )
```

```{r}
testDF %>%
  summarise( across( .cols  = x1:x5, 
                     .fns   = list(mn=mean, cv=cv), 
                     .names = "{.fn}_{.col}" ) )
```

<br>

<hr style = "border:2px solid #3559A6"> </hr>

<br>

# Anonymous functions

When you only want to use a function once, you might define it **in place** without naming it.

```{r}
testDF %>%
  summarise( across(x1:x2, function(x) sd(x) / mean(x)) )
```

There is another way of writing the same thing with a tilde, `~` and `.x`
```{r}
testDF %>%
  summarise( across(x1:x2, ~ sd(.x) / mean(.x)) )
```

You may see anonymous functions written in this style referred to as `lambda functions`.

The problem is that you have made the code more concise but slightly less legible. My advice is to avoid anonymous functions, where possible.

<br>

<hr style = "border:2px solid #3559A6"> </hr>

<br>

# Organising your functions

I place all of my functions in a special script file that I call `projectName_functions.R`, then I use `source()` to read those functions at the start of my regular scripts. This style is illustrated in the demonstration.

<br>

<hr style = "border:2px solid #3559A6"> </hr>

<br>

# Introduction to shiny

**shiny** is an R package for creating interactive graphics.  

A shiny app is created by a script called app.R that contains two user written functions **ui** and **server**

`ui` (user interface) controls the layout what appears on the screen

`server` monitors the screen to see if the user has requested any changes and when necessary it sends new output to the ui.

## The ui

In most applications, the appearance is designed as a fluid page using the fluidPage() function. The appearance is fluid because we are creating a webpage that might be viewed in any sized browser window or on a mobile phone. Shiny will resize your design as necessary. There is a fixedPage() alternative, but it is rarely the better option.

Within the fluid, page we can place the items as we choose. A popular option is `the sidebar layout` as provided by the sidebarLayout() function. This consists of a sidebar (by default on the left) and a main panel (by default to the right), where the main panel is twice the width of the sidebar. Typically the user interacts by changing something in the sidebar and the result is displayed in the main panel.

So the general code is
```{r eval=FALSE}
ui <- fluidPage(
  sidebarPanel(
    ..........
  ),
  mainPanel(
    ..........
  )
)
```
where the dots will be replaced by your specific choices.

The user can interact in a number of ways, clicking a button, moving a slider, picking from a list of options etc. and shiny provides **widgets** for each method. In this example, I plot a histogram of a column of data from a tibble with columns names x1:x3. The user will be free to pick the column, so the widget that I will need is called selectInput()

```{r eval=FALSE}
ui <- fluidPage(
  sidebarPanel(
    selectInput(
      inputId = "selection",
      label   = "pick a variable",
      choices = c("x1", "x2", "x3")
    )
  ),
  mainPanel(
    ..........
  )
)
```

The `inputId` is the name that I will use in my script when I want to refer to the user's choice. `label` is what appears above the widget and `choices` are the options that the user can chose from.

In the main panel, I want to plot the histogram. The shiny function for creating a plot is called plotOutput(). The contents of the plot will be controlled by the server() function so here we just need to reserve space for the plot and give it a name for use by server().

```{r eval=FALSE}
ui <- fluidPage(
  sidebarPanel(
    selectInput(
      inputId = "selection",
      label   = "pick a variable",
      choices = c("x1", "x2", "x3")
    )
  ),
  mainPanel(
    plotOutput(
      outputId = "histogram"
    )
  )
)
```

## server()

The server() function will monitor the screen and when the user selects a new variable it will detect the change and send the new histogram.  

server has two arguments input and output
```{r}
server <- function( input, output ) {
  output$histogram <- renderPlot({
    hist( testDF[[ input$selection]] )
  })
}
```

* The tibble containing the data is called testDF.  
* the choice made in the ui is called input$selection  
* hist() is the base R function for plotting a histogram  







